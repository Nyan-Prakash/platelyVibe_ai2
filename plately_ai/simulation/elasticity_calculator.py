# plately_ai/simulation/elasticity_calculator.py

import math

def calculate_arc_elasticity(q1, q2, p1, p2):
    """
    Calculates arc elasticity between two points (p1, q1) and (p2, q2).
    Formula: ((q2 - q1) / ((q1 + q2) / 2)) / ((p2 - p1) / ((p1 + p2) / 2))

    :param q1: Quantity at point 1
    :param q2: Quantity at point 2
    :param p1: Price at point 1
    :param p2: Price at point 2
    :return: Arc elasticity value, or None if inputs are problematic (e.g., division by zero).
    """
    # Avoid division by zero if average quantity or average price is zero,
    # or if prices or quantities haven't changed.
    if (q1 + q2) == 0 or (p1 + p2) == 0:
        return None # Or handle as infinity/zero based on which part is zero, but None is safer for general case
    if p1 == p2: # Price hasn't changed
        if q1 == q2: # Quantity also hasn't changed
            return 0.0 # No change, elasticity is 0
        else:
            return math.inf if (q2 - q1) > 0 else -math.inf # Infinite elasticity (perfectly elastic response to no price change - unusual)
            # Or more practically, return None or raise error as it's usually PED of a specific item
    if q1 == q2: # Quantity hasn't changed despite price change
        return 0.0 # Perfectly inelastic over this range

    avg_q = (q1 + q2) / 2
    avg_p = (p1 + p2) / 2

    percentage_change_q = (q2 - q1) / avg_q
    percentage_change_p = (p2 - p1) / avg_p

    if percentage_change_p == 0: # Should be caught by p1 == p2, but defensive
         return math.inf if percentage_change_q > 0 else (-math.inf if percentage_change_q < 0 else 0.0)


    elasticity = percentage_change_q / percentage_change_p
    return elasticity

def calculate_ped_from_simulation_data(ped_data_points):
    """
    Calculates Price Elasticity of Demand (PED) values from data generated by
    SimulationEngine.run_ped_simulation_set.

    Compares each scenario point to the baseline point.

    :param ped_data_points: A list of dictionaries from run_ped_simulation_set,
                            e.g., [{'price': P, 'demand': Q, 'is_baseline': bool, 'percentage_change': float}, ...]
    :return: A list of dictionaries, each containing:
             {'percentage_change': float, 'original_price': P_base, 'new_price': P_scenario,
              'original_demand': Q_base, 'new_demand': Q_scenario, 'ped_value': float or None}
             Returns an empty list if data is insufficient.
    """
    if not ped_data_points or len(ped_data_points) < 2:
        return []

    baseline_point = next((p for p in ped_data_points if p.get('is_baseline')), None)
    if not baseline_point:
        # Try to infer baseline if not explicitly marked, e.g., the one with percentage_change == 0
        baseline_point = next((p for p in ped_data_points if p.get('percentage_change') == 0.0), None)
        if not baseline_point:
            return [] # Cannot calculate without a clear baseline

    p_base = baseline_point['price']
    q_base = baseline_point['demand']

    results = []

    for point in ped_data_points:
        if point.get('is_baseline') or point.get('percentage_change') == 0.0: # Skip comparing baseline to itself
            continue

        p_scenario = point['price']
        q_scenario = point['demand']
        percentage_change = point.get('percentage_change', (p_scenario - p_base) / p_base if p_base != 0 else 0)

        ped_value = calculate_arc_elasticity(q_base, q_scenario, p_base, p_scenario)

        results.append({
            'percentage_change_price': percentage_change,
            'original_price': p_base,
            'new_price': p_scenario,
            'original_demand': q_base,
            'new_demand': q_scenario,
            'ped_value': ped_value
        })

    return results


def calculate_xed_from_simulation_data(xed_data):
    """
    Calculates Cross-Price Elasticity of Demand (XED) from data generated by
    SimulationEngine.run_xed_simulation_set.

    :param xed_data: A dictionary from run_xed_simulation_set.
                     Expected keys: 'q_target_base', 'q_target_scenario',
                                    'p_affecting_base', 'p_affecting_scenario'.
    :return: A dictionary containing the XED value and interpretation inputs:
             {'xed_value': float or None, 'target_item_name': str, 'affecting_item_name': str, ... (original data)}
             Returns None if input data is invalid.
    """
    if not xed_data or not all(k in xed_data for k in ['q_target_base', 'q_target_scenario', 'p_affecting_base', 'p_affecting_scenario']):
        return None

    q_target_base = xed_data['q_target_base']
    q_target_scenario = xed_data['q_target_scenario']
    p_affecting_base = xed_data['p_affecting_base']
    p_affecting_scenario = xed_data['p_affecting_scenario']

    xed_value = calculate_arc_elasticity(q_target_base, q_target_scenario, p_affecting_base, p_affecting_scenario)

    result = xed_data.copy() # Start with all original data
    result['xed_value'] = xed_value
    return result


if __name__ == '__main__':
    print("--- Testing calculate_arc_elasticity ---")
    # Test case 1: Standard elastic demand
    # Price increases from 10 to 12 (20% simple, ~18.18% arc)
    # Quantity decreases from 100 to 60 (40% simple, ~50% arc)
    # PED = -50 / 18.18 = -2.75 (approx)
    ped1 = calculate_arc_elasticity(q1=100, q2=60, p1=10, p2=12)
    print(f"PED Case 1 (Elastic): {ped1:.3f}") # Expected: -2.75

    # Test case 2: Inelastic demand
    # Price increases from 10 to 12
    # Quantity decreases from 100 to 90
    ped2 = calculate_arc_elasticity(q1=100, q2=90, p1=10, p2=12)
    print(f"PED Case 2 (Inelastic): {ped2:.3f}") # Expected: -0.579

    # Test case 3: Perfectly inelastic
    ped3 = calculate_arc_elasticity(q1=100, q2=100, p1=10, p2=12)
    print(f"PED Case 3 (Perfectly Inelastic): {ped3}") # Expected: 0.0

    # Test case 4: Price constant, quantity changes (infinite elasticity)
    ped4 = calculate_arc_elasticity(q1=100, q2=120, p1=10, p2=10)
    print(f"PED Case 4 (Infinite): {ped4}") # Expected: inf

    # Test case 5: Quantity constant, price constant
    ped5 = calculate_arc_elasticity(q1=100, q2=100, p1=10, p2=10)
    print(f"PED Case 5 (Zero change): {ped5}") # Expected: 0.0

    # Test case 6: XED - Substitutes (Price of B up, Qty of A up)
    # P_B from 5 to 6. Q_A from 20 to 25.
    xed1 = calculate_arc_elasticity(q1=20, q2=25, p1=5, p2=6)
    print(f"XED Case 1 (Substitutes): {xed1:.3f}") # Expected: positive, e.g. 1.222

    # Test case 7: XED - Complements (Price of B up, Qty of A down)
    # P_B from 5 to 6. Q_A from 20 to 15.
    xed2 = calculate_arc_elasticity(q1=20, q2=15, p1=5, p2=6)
    print(f"XED Case 2 (Complements): {xed2:.3f}") # Expected: negative, e.g. -1.556

    # Test with problematic input (avg quantity is zero)
    ped_problem = calculate_arc_elasticity(q1=0, q2=0, p1=10, p2=12)
    print(f"PED Problem (Zero Avg Qty): {ped_problem}") # Expected: None or specific handling

    print("\n--- Testing calculate_ped_from_simulation_data ---")
    sample_ped_data = [
        {'price': 10.0, 'demand': 100, 'is_baseline': True, 'percentage_change': 0.0},
        {'price': 12.0, 'demand': 60, 'is_baseline': False, 'percentage_change': 0.2}, # PED should be -2.75
        {'price': 8.0, 'demand': 150, 'is_baseline': False, 'percentage_change': -0.2} # PED vs baseline (100,10) & (150,8)
    ]
    ped_results = calculate_ped_from_simulation_data(sample_ped_data)
    print(f"PED Results from Sim Data: {ped_results}")
    # Expected: [{'percentage_change_price': 0.2, ..., 'ped_value': -2.75},
    #            {'percentage_change_price': -0.2, ..., 'ped_value': -2.25}] (approx for second one)

    print("\n--- Testing calculate_xed_from_simulation_data ---")
    sample_xed_data = {
        'target_item_name': 'Item A', 'target_item_id': 'A1',
        'affecting_item_name': 'Item B', 'affecting_item_id': 'B1',
        'q_target_base': 20, 'q_target_scenario': 25, # Demand of A increases
        'p_affecting_base': 5.0, 'p_affecting_scenario': 6.0, # Price of B increases
        'percentage_change_p_affecting': 0.2
    }
    xed_result = calculate_xed_from_simulation_data(sample_xed_data)
    print(f"XED Result from Sim Data: {xed_result}")
    # Expected: xed_value approx 1.222, items are substitutes.

    sample_xed_data_complement = {
        'target_item_name': 'Item C', 'target_item_id': 'C1',
        'affecting_item_name': 'Item D', 'affecting_item_id': 'D1',
        'q_target_base': 50, 'q_target_scenario': 40, # Demand of C decreases
        'p_affecting_base': 7.0, 'p_affecting_scenario': 8.0, # Price of D increases
        'percentage_change_p_affecting': 0.142857
    }
    xed_result_complement = calculate_xed_from_simulation_data(sample_xed_data_complement)
    print(f"XED Result (Complement) from Sim Data: {xed_result_complement}")
    # Expected: xed_value approx -1.5 (negative), items are complements.

    print("\n--- Testing with missing baseline in PED data ---")
    missing_baseline_ped_data = [
        {'price': 12.0, 'demand': 60, 'is_baseline': False, 'percentage_change': 0.2},
        {'price': 8.0, 'demand': 150, 'is_baseline': False, 'percentage_change': -0.2}
    ]
    ped_results_no_baseline = calculate_ped_from_simulation_data(missing_baseline_ped_data)
    print(f"PED Results (no explicit baseline): {ped_results_no_baseline}") # Expected: [] or error, now tries to infer

    infer_baseline_ped_data = [
        {'price': 10.0, 'demand': 100, 'percentage_change': 0.0}, # Infer this as baseline
        {'price': 12.0, 'demand': 60, 'percentage_change': 0.2},
    ]
    ped_results_infer_baseline = calculate_ped_from_simulation_data(infer_baseline_ped_data)
    print(f"PED Results (infer baseline): {ped_results_infer_baseline}")
    # Expected: one result with PED ~ -2.75

    print("\n--- Testing PED with zero initial demand ---")
    zero_demand_ped_data = [
        {'price': 10.0, 'demand': 0, 'is_baseline': True, 'percentage_change': 0.0},
        {'price': 8.0, 'demand': 10, 'is_baseline': False, 'percentage_change': -0.2},
    ]
    ped_results_zero_demand = calculate_ped_from_simulation_data(zero_demand_ped_data)
    print(f"PED Results (zero initial demand): {ped_results_zero_demand}")
    # Expected: ped_value is None or inf, as (q1+q2)/2 can be non-zero, but q1 is 0.
    # The calculate_arc_elasticity handles (q1+q2)==0 returning None.
    # If q1=0, q2=10, avg_q = 5. (10-0)/5 = 2.
    # If p1=10, p2=8, avg_p = 9. (8-10)/9 = -0.222.
    # Elasticity = 2 / -0.222 = -9.0 (approx) - This is valid.
    # The case where (q1+q2)==0 should return None.
    # If q1=0, q2=0, then (q1+q2)==0, returns None. This is correct.

    print("\n--- Testing XED with zero initial target demand ---")
    zero_xed_data = {
        'target_item_name': 'Item A', 'target_item_id': 'A1',
        'affecting_item_name': 'Item B', 'affecting_item_id': 'B1',
        'q_target_base': 0, 'q_target_scenario': 5,
        'p_affecting_base': 5.0, 'p_affecting_scenario': 6.0,
        'percentage_change_p_affecting': 0.2
    }
    xed_result_zero = calculate_xed_from_simulation_data(zero_xed_data)
    print(f"XED Result (zero initial target demand): {xed_result_zero}")
    # Expected: xed_value can be calculated (similar to PED zero initial demand).
    # (5-0)/2.5 = 2. (6-5)/5.5 = 0.1818. XED = 2 / 0.1818 = 11.0 (approx)

    print("\n--- Testing PED with no change in price or demand ---")
    no_change_ped_data = [
        {'price': 10.0, 'demand': 100, 'is_baseline': True, 'percentage_change': 0.0},
        {'price': 10.0, 'demand': 100, 'is_baseline': False, 'percentage_change': 0.0},
    ]
    ped_results_no_change = calculate_ped_from_simulation_data(no_change_ped_data)
    print(f"PED Results (no change): {ped_results_no_change}")
    # The loop skips if percentage_change is 0.0 and not baseline.
    # If the point was not marked as baseline and had pc=0, it's compared.
    # calculate_arc_elasticity(100,100,10,10) returns 0.0. Correct.

    print("\n--- Testing PED with price change but no demand change ---")
    no_demand_change_ped_data = [
        {'price': 10.0, 'demand': 100, 'is_baseline': True, 'percentage_change': 0.0},
        {'price': 12.0, 'demand': 100, 'is_baseline': False, 'percentage_change': 0.2},
    ]
    ped_results_no_demand_change = calculate_ped_from_simulation_data(no_demand_change_ped_data)
    print(f"PED Results (no demand change): {ped_results_no_demand_change}")
    # Elasticity should be 0.0. Correct.

    print("\n--- Testing PED with demand change but no price change ---")
    no_price_change_ped_data = [
        {'price': 10.0, 'demand': 100, 'is_baseline': True, 'percentage_change': 0.0},
        {'price': 10.0, 'demand': 120, 'is_baseline': False, 'percentage_change': 0.0}, # Percentage change here refers to price.
    ]
    # Manually set percentage_change for the scenario point if it's from a run where price didn't change
    # but we still want to see elasticity if demand changed for other reasons (unusual for PED context)
    # The calculate_ped_from_simulation_data recalculates pc based on price if not provided.
    # Here, prices are same, so calculate_arc_elasticity returns inf.
    ped_results_no_price_change = calculate_ped_from_simulation_data(no_price_change_ped_data)
    print(f"PED Results (no price change, demand changes): {ped_results_no_price_change}")
    # Correctly, the loop will use the point's percentage_change (0.0),
    # then calculate_arc_elasticity(100, 120, 10, 10) will yield inf.
    # The first value in results is for the second item in the list.
    # The 'percentage_change_price' in the output dict will be 0.0.
    # The 'ped_value' will be inf. This is correct.
